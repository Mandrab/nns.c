<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>nns.c: headers/util/components.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">nns.c
   &#160;<span id="projectnumber">1.0.1</span>
   </div>
   <div id="projectbrief">Nanowire Network simulator</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('components_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">components.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Contains utility functions to work with connected components of a Nanowire Network. The only function that is supposed to be used directly by a user is <code>split_components</code>.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="network_8h_source.html">device/network.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="component_8h_source.html">device/component.h</a>&quot;</code><br />
</div>
<p><a href="components_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a8edd6596e974faa8d6febbad8baf3d99"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="components_8h.html#a8edd6596e974faa8d6febbad8baf3d99">map_components</a> (const <a class="el" href="structdatasheet.html">datasheet</a> ds, const <a class="el" href="structnetwork__topology.html">network_topology</a> nt, int n2c[])</td></tr>
<tr class="memdesc:a8edd6596e974faa8d6febbad8baf3d99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a network topology and its corresponding datasheet, generate an array containing for each node the index of the parent connected component and return the number of connected components discovered.  <a href="components_8h.html#a8edd6596e974faa8d6febbad8baf3d99">More...</a><br /></td></tr>
<tr class="separator:a8edd6596e974faa8d6febbad8baf3d99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50c21a86554c18efddef763bdc995f05"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="components_8h.html#a50c21a86554c18efddef763bdc995f05">group_nanowires</a> (const <a class="el" href="structdatasheet.html">datasheet</a> ds, <a class="el" href="structnetwork__topology.html">network_topology</a> nt, int n2c[], int cc_count)</td></tr>
<tr class="memdesc:a50c21a86554c18efddef763bdc995f05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort the Ws and Js arrays of <code>nt</code> according to the index of the connected component each entry belongs to. The index is specified by the <code>n2c</code> array. Once <code>nt</code> is sorted, also the entries of the <code>n2c</code> arrays are corrected to match those of the new <code>nt</code>. E.g.:  <a href="components_8h.html#a50c21a86554c18efddef763bdc995f05">More...</a><br /></td></tr>
<tr class="separator:a50c21a86554c18efddef763bdc995f05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ebd78bc338250591ed25b709bde082c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structconnected__component.html">connected_component</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="components_8h.html#a1ebd78bc338250591ed25b709bde082c">split_components</a> (const <a class="el" href="structdatasheet.html">datasheet</a> ds, const <a class="el" href="structnetwork__topology.html">network_topology</a> nt, int n2c[], int cc_count)</td></tr>
<tr class="memdesc:a1ebd78bc338250591ed25b709bde082c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create <code>cc_count</code> connected components referencing the sub-arrays of <code>ns</code> containing the data belonging to them. Since the wires and the junctions are ordered according to the CC index, it is enough to know the starting point of the arrays (i.e., ws_skip and js_skip) and their length (i.e., ws_count and js_count). Additionally, calculate and save the index of the junctions in the CC-specific adjacency matrix (see Is array).  <a href="components_8h.html#a1ebd78bc338250591ed25b709bde082c">More...</a><br /></td></tr>
<tr class="separator:a1ebd78bc338250591ed25b709bde082c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Contains utility functions to work with connected components of a Nanowire Network. The only function that is supposed to be used directly by a user is <code>split_components</code>. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a50c21a86554c18efddef763bdc995f05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50c21a86554c18efddef763bdc995f05">&#9670;&nbsp;</a></span>group_nanowires()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void group_nanowires </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdatasheet.html">datasheet</a>&#160;</td>
          <td class="paramname"><em>ds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnetwork__topology.html">network_topology</a>&#160;</td>
          <td class="paramname"><em>nt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n2c</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cc_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sort the Ws and Js arrays of <code>nt</code> according to the index of the connected component each entry belongs to. The index is specified by the <code>n2c</code> array. Once <code>nt</code> is sorted, also the entries of the <code>n2c</code> arrays are corrected to match those of the new <code>nt</code>. E.g.: </p>
<div class="fragment"><div class="line">n2c = [0, 1, 0, 2, 1]</div>
<div class="line">ws  = [a, b, c, d, e]</div>
<div class="line">         |</div>
<div class="line">        \/</div>
<div class="line">ws  = [a, c, b, e, d]</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ds</td><td>The datasheet describing the Nanowire Network. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">nt</td><td>The topology of the Nanowire Network to sort. Ws will be sort according to the CC index, original first wire index, and original second wire index. Js will be sorted according to the new indexes of the wires. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">n2c</td><td>An array of length 'ds.wires_count' containing for each entry the index of the parent connected component. After the function call it will contain the entries sorted to match the Ws wires. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cc_count</td><td>The number of connected components discovered in the NN. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8edd6596e974faa8d6febbad8baf3d99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8edd6596e974faa8d6febbad8baf3d99">&#9670;&nbsp;</a></span>map_components()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int map_components </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdatasheet.html">datasheet</a>&#160;</td>
          <td class="paramname"><em>ds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnetwork__topology.html">network_topology</a>&#160;</td>
          <td class="paramname"><em>nt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n2c</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a network topology and its corresponding datasheet, generate an array containing for each node the index of the parent connected component and return the number of connected components discovered. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ds</td><td>The datasheet describing the Nanowire Network. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nt</td><td>The topology of the Nanowire Network. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">n2c</td><td>An array of length 'ds.wires_count' containing for each entry the index of the parent connected component. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of connected components discovered in the NN. </dd></dl>

</div>
</div>
<a id="a1ebd78bc338250591ed25b709bde082c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ebd78bc338250591ed25b709bde082c">&#9670;&nbsp;</a></span>split_components()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structconnected__component.html">connected_component</a>* split_components </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdatasheet.html">datasheet</a>&#160;</td>
          <td class="paramname"><em>ds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnetwork__topology.html">network_topology</a>&#160;</td>
          <td class="paramname"><em>nt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n2c</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cc_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create <code>cc_count</code> connected components referencing the sub-arrays of <code>ns</code> containing the data belonging to them. Since the wires and the junctions are ordered according to the CC index, it is enough to know the starting point of the arrays (i.e., ws_skip and js_skip) and their length (i.e., ws_count and js_count). Additionally, calculate and save the index of the junctions in the CC-specific adjacency matrix (see Is array). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ds</td><td>The datasheet describing the Nanowire Network. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nt</td><td>The topology of the Nanowire Network. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n2c</td><td>An array of length 'ds.wires_count' containing for each entry the index of the parent connected component. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cc_count</td><td>The number of connected components discovered in the NN. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The array of <code>cc_count</code> initialized connected components. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_7f57b1e41c5acd0e859ae5f3a2b075a9.html">headers</a></li><li class="navelem"><a class="el" href="dir_bc4f3d3130ea46cbb34c9fa0d9c95a03.html">util</a></li><li class="navelem"><a class="el" href="components_8h.html">components.h</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
